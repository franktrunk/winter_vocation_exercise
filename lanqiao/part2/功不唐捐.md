
# 模拟法
## 描述
* 一般来说就是暴力遍历
* 非常简单，不是算法的算法
## 题目列表
### 日期问题
* 日期计算
* 判断日期是否合法
* 去重
### REPEAT程序



# 枚举法
## 描述
* 又称暴力算法，将所有可能都列举出来，应当考虑如何减少
## 题目列表
### 百钱买百鸡
* 本题难点在于如何减少我们要枚举的数量
* 要让鸡和钱数平衡，必须有小鸡
* 一只母鸡配三只小鸡，一只公鸡配六只小鸡
* 这样未知数就变成了两个，同时不定方程的性质找到一组解后可以根据每次加减系数（最小公倍数平衡）来迅速求解所有
### 等差素数数列
* 先使用筛法找出足够多的素数，当然这里采用bool数组可以节省不少空间
*  然后尝试不同的公差，找不同的素数为起点，进行计算
### 乘积尾零
* 方法一：每次计算一会儿对0进行统计，然后让值变小，再计算
* 方法二：质因数分解，计算所有值中的5和2的个数，然后取最小值
### 数的分解
* 首先由于等式关系我们可以把变量降低为2个
* 为了避免重复性，可以规定三个数字的大小关系
* 依据大小关系，将循环的结束条件范围减少
* 然后判断每个数字上是否有数字2或者4
### 特别数之和
* 写一个judge函数，判断是否有2、0、1、9四个数字就可以了
### 完全二叉树的权值
* 本题就是考察二叉树结构，以及结点数和深度的关系
### 等差数列
* 先对原始数列进行排序
* 计算相邻两个数之间的公差
* 求出所有公差的最大公约数
* 利用公差项数公式计算
### 跑步训练
* 这个类似于高中物理的刹车陷阱，把600这个临界点处理好就可以了。
### 合并检测
* 如果看不出数学规律，先列表试探一下曲线，然后就根据公式求最小值就好
### 求直线
* 循环求直线
* 利用set去重
### 货物摆放
* 先找约数，把遍历的范围缩小
* 找约数也是有讲究的，找到平方根位置，约数成对出现。
* 最后三重循环遍历就好
  
### 生日蜡烛
* 没啥好说的，先可以除以2、3等试探一下，缩小范围
### 奖券数目
* 用乘法原理更好，傻瓜题
### 不定方程求解
* 先找系数的最小公倍数，除以各自，然后每次加这个值。
* 用辗转相除法求最大公约数
* 乘积除以最大公约数等于最小公倍数
* 先求一个极端特解再去找所有的解，遍历间隔变大，遍历次数减小
### 选数
* 先跳过一下，因为它写的函数有问题
### 火柴棍等式
* 首先输出每个数字对应的火柴数
* 留意=和+共花费4个火柴
* a、b构成二重循环，c=a+b进行枚举
* 写一个计算不同数字花费火柴数的函数
* 先估算，估算尽量用花费火柴数少的1来扩大位数圈出一个粗定的范围
### 比例简化
* 这是一个不错的题目
* 首先运用数学运算，化除法为乘积
* 保证差值最小，需要我们知道，对每一个合理的解，当我们确定A的时候，可以尝试增大B除非破坏前一个条件，于是这就会有一个单调递减的比值数列，然后转换一下就又是一个乘积不等式
* 初始化也有考究，有时候初始化只是为了让它跑起来，所以不妨依据某一个条件的极端值，保证他一定可以跑起来即可。

# 递推与递归
## 描述
### 递推法：
* 将复杂计算转换为若干步简单的计算
* 多米诺骨牌：递推。把一个问题分解，如果最后放一块竖着的，最后放两块横着的这两种情况就可以很好写出一个递推式，也许本质上就是因为骨牌只有两种放法
### 递归法：
* 函数对自身的调用
## 题目列表
### 承压计算
* 从上向下逐步更新下一层的重量，最后取电子秤读数最大的。
* 考虑到double的精度，整体扩大2的29次方倍
* 先给数组每一个赋值，后续加上的重量通过递推法从上到下遍历。
### 取数位
* 太简单了，略
### 数列求值
* 这个题给我最大的启示就是模运算，每次只需要留后4位，这样就不必担心溢出
### 快速排序
### 组合数
* 组合数公式，没啥好说的
### 李白打酒
* 本题采用递归法，首先找到临界条件
* 再无脑用递归表达式就OK
* 其实这也给了我一个启示，递归似乎不需要你理解的很透彻，它本身就是一种计算量换思维量的方法

### 组合数
* 好吧，如果非要用递归确实不好想，但是用枚举法就成了一个简单的问题
* 首先还是圈出遍历的范围
* 统计所用数字的个数

### 带分数
* 
# 贪心算法
## 描述
* 不从整体最优上入手，而是从某种意义上的局部最优
* 建立数学模型描述问题
* 把求解的问题分解为若干个子问题
* 对每个子问题进行求解，得到子问题的局部最优解
* 把子问题的局部最优解合成为原问题的一个解
* 但是仔细思考之后，贪心只是描述你的方法的一个词，这个方法具体的思路是经得起推敲的

## 题目列表
### 分巧克力
* 使用二分法不断逼近
* 成功了就移动下界，否则就移动上界。
### 递增三元组
* 本题技巧很有灵性，让我产生了很浓厚的兴趣
* 首先就是它把b作为一个媒介，打破了直观的三重循环思路
* 用查询算法，b并不一定查得到，但是使用二分会给它一个合适的位置，再通过调整二分的结构，让这个位置满足我们想要的条件：a<b<c。
* 查询算法复杂度很低，只需要遍历b再配合查询算法和乘积计算就可以得到结果，算法复杂度远远小于n的三次方
### 乘积最大
* 这是一道考察分类能力的题目
* 首先对k进行讨论
* 如果k等于n，那没什么好说的，  全部乘起来就好
* 如果k小于n，那么需要分奇数还是偶数
* 如果是偶数那就好说了，可以确定最后结果一定不是负数
* 如果是奇数的话，那就看是不是全为负数
* 如果全部是负数，那就最后一定是负数，所以要尽可能找绝对值小的负数
* 如果不全为负数，那就好办了，最后一定不能是负数，还是尽可能找绝对值大的来乘。
* 这个解法巧妙在sign的设置
* 如果是偶数，sign为正，两头找绝对值大的组合，没什么好说的。
* 如果是奇数，那就得考察符号了，如果都是负数，那么符号得改变了结果一定是负数
* 此时绝对值大的反而小，所以取值条件还是正确的
* 如果不全为负数那就和偶数处理方法没区别
### 后缀表达式
  
### 删数
* 这个题的贪心策略应该是让我们留下来的数尽可能保持升序
* 可以证明
* 然后要注意可能最后一个字符没有加入到ans中去
* 也要注意可能没删完，那就从后往前删几个
* 多积累吧，题目见多了才能形成一定的思维

### 翻硬币
* 首先分析极端情况，第一个和最后一个，如果它们不对的话就只有一种翻硬币情况，（不要做没意义的重复翻动作）
* 那么就可以递推，第一个翻好了就不要动它，那么此时第二个就变成了第一个，回到了已经分析过的情况
* 所以就是从头到尾遍历就OK

### 分糖果
* 




# 搜索算法
* 深度优先：从图中一个未访问的顶点开始，沿一条路一直走到底，然后从这条路尽头的结点回退到上一个节点，再从另一条路走到底，直到遍历所有结点
* 广度优先：从图中一个未访问的顶点开始，遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。
## 题目列表
### 方格分割
* 首先确定开始搜索的点，中心点
* 处理对称性：除以4
* 标记对称点：每次搜索一个点。必然导致一个对称点无法被搜索
* 用数组来表示搜索方向
* 只要搜索点到了边界，它的对称点也一定到了边界，按照轨迹来切割就一定是对称的
* 由于用的是全局数组，所以每次搜索完后都要恢复状态
### 组队
* 本题适合使用深度优先算法
* 每个选手在5个位置上得分不同，哪怕是0也没有关系，反正我们最后找到的一定是最大值的情况
* 设置一个标记数组，来标记本轮搜索某个选手是否已经入队
* 用全局变量来表示搜索深度，深度大于5的时候就要返回
* 每次标记一个队员进入深一层的搜索，搜索完了回溯要把这个队员标记失效
* 要改变想法，递归和循环并一定是互不相容的。
* 遍历是搜索的目的，深度优先是遍历的手段
### 全球变暖
* 傻逼题解，爬，网上也是一堆错误
### 迷宫
* 这个题目告诉了我DFS回溯比较多，容易爆栈，所以使用BFS广度优先。但是BFS搜索是不记录路径的，为了记录路径和方向，需要设计一个结构体。
* 首先字典序最小，那么搜索优先级上我们采用DLRU来搜索，这样除非步数更少覆盖掉，否则字典序一定是最小的
* 搜索路径的记录：记录搜索点的坐标和搜索的方向字母，f来记录搜索点的父节点
* 路径的输出：最后需要逆向输出，先找最后一个节点，再找它的父结点，把父结点的内容插到前方，直到起始为止

### 凑算式
* DFS可以带来代码量的减少
* 用DFS来构造全排列，再进行计算验证

### 玩具蛇
* 典型的dfs
* 首先需要观察到，起点可以是任何位置，用这个来遍历可以做到不重不漏
* 然后就是无脑dfs了，终止深度为16（蛇的长度），保证遍历的时候不能越界

### 递归入门
* 搞清楚递归的区分条件，选择当前数和不选择当前数
* 递归深度作为终止条件
* 就是个递归，没那么玄乎
* 把握好控制条件

### 



# 动态规划
## 描述
* 将待求解的问题分解为若干子问题，然后按照顺序求解子问题
* 前一子问题的解为后一子问题的求解提供了有用的信息
* 求解任一子问题时，列出各种可能的局部解，通过决策保留可能达到最优的局部解丢弃其他局部解
* 最后一个子问题的解就是初始问题的解
* 把问题方程化，状态转移方程
* 按照实际逻辑设置边界情况和初始条件
* 确定子问题的计算顺序
* 为了减少重复计算，每个子问题只求解一次，把不同阶段的状态保存在数组中
* 和分治法的区别：动态规划的子问题不是相对独立的

## 题目列表
### 0-1背包问题
* 二维数组，放入n个东西可容纳m斤的最大价值，可容纳m斤不代表一定装满了
* 状态转移方程的构建：根据是否放入第i个物品来分类，放入之后减重+价值。不放入则不改变，之间去讨论下一个
* 初始条件和边界情况： 对0件物品和0重量的讨论
* 构造方程是从后往前的，但是求解却是从前往后的
* 回溯：推算放进去的东西到底是哪些
* 试探某一件东西有没有放进去，看它和它相邻的值有没有区别
### 包子凑数
* 两个数及其能表示出来的数一定是他们的公约数的倍数
* 对于多个数，同样有这个定理，如果这多个数的公约数是1的话，则存在最大的不能表示出来的数，否则不存在
* 题目给定的ai值小于等于100，又因为100以内最大的互质的两个数是99和100，所以100以内的所有数的最大的不能表示出来的数不超过99*100=9900，我们可以把10000设为上界
* 然后划归为背包问题，如果某个解法为0，那么结果就+1
### K倍区间
* 前缀和算法：求数字的前i项和
* 前i项数组和对K的余等于前K项数组的和对K的余，那么[i+1,j]一定是K倍区间
* 定义一个num数组统计arr[i]%k==arr[j]%k（前缀数组）的个数，num的下标就是余数
* 每次来一个数，计算arr，然后对应的num[余数]+1;
* 更新count的时候数的是区间，正好就是num[arr[i]]个新区间，然后更新num[arr[i]]的值
* 最后要+num[0]，因为我们前面的逻辑是区间作差，但是没有考虑模数等于0区间本身也是符合的
### 测试次数
* 这个题目也很有意思，需要我们仔细品味最佳策略和最坏运气
* 最坏运气会导致最多的测试数量，这体现在不同楼层可以选择导致更多测量次数的情况
* 最佳策略会选择次数少的方法。
### 矩阵
* 写书的人是傻逼，这一点毋庸置疑
* 默认填数字从小往大填，那么只要下一行数字比上一行少或者相等，咱们就可以保证题目条件，填进去的数字逐个递增不会影响
* 其实说明白这个事情，和题目条件就没啥用了，但是傻逼作者不讲清楚
* 写转移方程就行了，不想看了，闹心
###  走方格
* 要学会发掘题目中隐藏的构造状态转移方程的细节：比如这里只能向右和向下走，那么递推上一个状态只有两种
* 初始化f[1][1]为1，然后初始化为0，碰到偶数就不会更新
* 最后遍历求解整个数组，输出想要的解就可以而来
### 砝码称重
*  首先设置数组dp[i][j]。表示i个砝码可以称的重量j。
*  其实这么设置的话，这个数组也可以使用bool
*  分析重量j和加入的砝码a[i]的大小关系，进而讨论状态转移方程
*  如果重量等于加入的砝码重量，dp[i][j]=1
*  如果重量j大于加入的砝码a[i]，那么就考虑d[i-1][j-a[i]]的值，因为现在只能靠前面的i-1个砝码来补足重量了
*  当然这种讨论还需要考虑d[i-1][j]是否能把重量称出来
*  当j<a[i]， dp[i][j]=dp[i-1][a[i]-j]
*  这个也要考虑d[i-1][j]是否能把重量称出来
### 括号序列
*  懒得看
### 爬楼梯
* 斐波拉契类似
### 数字三角形
* 题目要求从顶到底，但是我们没必要非这样做，从底往顶可以避免边界问题